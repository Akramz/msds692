# Data translation pipeline

## Goal

The goal of this  homework is to study the most common text-based data formats: `csv`, `xml`, `json`, and `html`. Parsing data files can be tricky, but generating them is easy. In this first homework, you will therefore be generating data in multiple formats but using standard Python libraries to read that data back in. The exception is that you will be parsing comma-separated value (CSV) files the hard way. 

The basic idea is that you will be able to read in some data in csv format and pass it  along a pipeline of data conversions, ultimately getting it back to the original format:

<img src=figures/pipeline.png width=500>

From the commandline, it will look like this:

```bash
$ cat data.csv | \
  python csv2xml.py | \
  python xml2csv.py | \
  python csv2json.py | \
  python json2csv.py > samedata.csv
$ diff data.csv samedata.csv | wc
       0       0       0
```

The last  command just checks to make sure that there is no difference between the original file and the data after it's been pushed through the pipeline.

You will work in git repo *userid*-pipeline.

## Description

### Getting some initial stock data

Grab Apple's 35 year stock history using this URL

```
http://ichart.finance.yahoo.com/table.csv?s=AAPL
```

The file generated by that website is a CSV file with 8996 lines, which we can discover easily with `wc`:
 
```bash
$ wc ~/github/msan692/data/AAPL.csv
    8996    8997  583817 /Users/parrt/github/msan692/data/AAPL.csv
```

The first thing to notice is that there is a header row that describes the data in the various columns.
 
```bash
$ head ~/github/msan692/data/AAPL.csv
Date,Open,High,Low,Close,Volume,Adj Close
2016-08-12,107.779999,108.440002,107.779999,108.18,18612300,108.18
2016-08-11,108.519997,108.93,107.849998,107.93,27484500,107.93
2016-08-10,108.709999,108.900002,107.760002,108.00,24008500,108.00
```

The data follows the header row, with one record per line. The key element of the CSV format is the separator, more specifically the venerable comma. It is the column or field separator that allows us to distinguish between the elements. For *m* columns, there are *m-1* separators. For *n* records, there are *n* lines (with possibly a header row in addition).

### Parsing simple CSV files

It's often best to start with a tiny input example before tackling the overall problem. I made a small CSV file:
 
```csv
when,a,b
2016-08-12,1.2,3
2016-08-13,3.99003,4.3
```

To parse that, we read the file and convert it to a list of lines and then we split each line on commas. That gives us a list of lists. Of course, the first line of the file is special; it is the header row. Let's get that first task out of the way then by completing the following code in `csv.py`:

```python
import sys

def getdata():
    if len(sys.argv)==1: # if no file given, read from stdin
        data = sys.stdin.read()
    else:
        f = open(sys.argv[1], "r")
        data = f.read()
        f.close()
    return data.strip()

def readcsv(data):
    """
    Read CSV with header from data string and return a header list
    containing a list of names and also return the list of lists
    containing the data.
    """
    ...
    return headers, data
```

Here is a sample Python script that prints out the results of our `readcsv` function:

```python
headers, data = csv.readcsv(csv.getdata())
print headers
print data
```

Running with my simple test file, we'd generate this output:

```bash
$ python test_readcsv.py < testdata.csv
['when', 'a', 'b']
[['2016-08-12', '1.2', '3'], ['2016-08-13', '3.99003', '4.3']]
```

Or, if you want to go back to csv format, you could use the following Python code:

```python
print "headers =", ','.join(headers)
for row in data:
    print ','.join(row)
```

###  Generating HTML

```html
<html>
<body>
<table>
<tr><th>when</th><th>a</th><th>b</th></tr>
<tr><td>2016-08-12</td><td>1.2</td><td>3.0</td></tr>
<tr><td>2016-08-13</td><td>3.99003</td><td>4.3</td></tr>
</table>
</body>
</html>
```

<img src="figures/testdatahtml.png" width=170>

<img src="figures/datahtml.png" width=450>

### Generating XML

```xml
<?xml version="1.0"?>
<file>
  <headers>when,a,b</headers>
  <data>
    <record>
      <when>2016-08-12</when><a>1.2</a><b>3.0</b>
    </record>
    <record>
      <when>2016-08-13</when><a>3.99003</a><b>4.3</b>
    </record>
  </data>
</file>
```

From within the chrome browser, the real XML data from the AAPL history looks like this (although I may have added an XML viewer plug into the browser):
 
<img src="figures/dataxml.png" width=300>

### Generating JSON

```bash
$ python csv2json.py < testdata.csv > /tmp/t.json
```

```json
{
  "headers":["when", "a", "b"],
  "data":[
    {
      "when":"2016-08-12", "a":"1.2", "b":"3"
    },
    {
      "when":"2016-08-13", "a":"3.99003", "b":"4.3"
    },
    {
      "when":""
    }
  ]
}
```

### Reading JSON data

```bash
$ python json2csv.py < /tmp/t.json
```

### Reading XML Data

## fsdf

## Deliverables

* csv.py
* csv2html.py
* csv2json.py
* csv2xml.py
* json2csv.py
* xml2csv.py
